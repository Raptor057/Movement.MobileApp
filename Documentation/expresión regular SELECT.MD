# ExpresiÃ³n Regular `SELECT`
**expresiÃ³n regular mejorada** para validar un **`SELECT` en SQLite**, asegurando que siga la sintaxis correcta y respete las palabras reservadas:

```regex
^(?<StartQuery>SELECT)\s+(?<Columns>.+?)\s*\n(?<QueryFrom>FROM)\s+(?<TableName>[A-Za-z_][A-Za-z0-9_]*)\s*(?<Joins>(?:\s+JOIN\s+[A-Za-z_][A-Za-z0-9_]*\s+ON\s+.+?)*)?\s*(?<WhereClause>(?:\s+WHERE\s+.+?)?)\s*(?<GroupByClause>(?:\s+GROUP\s+BY\s+.+?)?)\s*(?<OrderByClause>(?:\s+ORDER\s+BY\s+.+?)?)\s*(?<LimitClause>(?:\s+LIMIT\s+\d+)?)\s*(?<EndOfQuery>;)$

```

----------

### **ğŸ“Œ ExplicaciÃ³n de los grupos nombrados:**

1.  **`StartQuery`** â†’ `SELECT` (debe iniciar con esta palabra clave).
2.  **`Columns`** â†’ Lista de columnas seleccionadas (`*` o nombres de columnas separadas por `,`).
3.  **`QueryFrom`** â†’ `FROM` seguido del **nombre de la tabla principal**.
4.  **`Joins`** _(opcional)_ â†’ `JOIN ... ON ...` para validar `INNER JOIN`, `LEFT JOIN`, etc.
5.  **`WhereClause`** _(opcional)_ â†’ `WHERE` con condiciones.
6.  **`GroupByClause`** _(opcional)_ â†’ `GROUP BY` con columnas de agrupaciÃ³n.
7.  **`OrderByClause`** _(opcional)_ â†’ `ORDER BY` para ordenar resultados.
8.  **`LimitClause`** _(opcional)_ â†’ `LIMIT` para limitar el nÃºmero de registros.
9.  **`EndOfQuery`** â†’ `;` (debe finalizar con punto y coma).

----------

### **ğŸ” Ejemplos de consultas vÃ¡lidas:**

âœ” **Consulta simple:**

```sql
SELECT id, name 
FROM Users;

```

âœ” **Consulta con `JOIN`:**

```sql
SELECT U.id, U.name, O.order_id, O.amount 
FROM Users U 
INNER JOIN Orders O ON U.id = O.user_id;

```

âœ” **Consulta con `WHERE`, `GROUP BY`, `ORDER BY` y `LIMIT`:**

```sql
SELECT S.date, SUM(S.amount) AS TotalSales 
FROM Sales S 
WHERE S.date > '2024-01-01' 
GROUP BY S.date 
ORDER BY S.date DESC 
LIMIT 10;

```

----------

### **ğŸš¨ Casos incorrectos que NO pasarÃ­an la validaciÃ³n:**

âŒ **Falta `FROM` en la consulta**

```sql
SELECT id, name;

```

âŒ **No tiene punto y coma (`;`) al final**

```sql
SELECT id, name 
FROM Users

```

----------

### **ğŸ“Œ Beneficios de esta expresiÃ³n regular:**

âœ… **Valida la estructura completa de un `SELECT` en SQLite**.  
âœ… **Permite nombres de tablas/columnas con letras, nÃºmeros y `_`**.  
âœ… **Soporta `JOIN`, `WHERE`, `GROUP BY`, `ORDER BY`, `LIMIT` opcionales**.  
âœ… **Asegura que el query termina con `;`**.  
âœ… **Evita consultas mal formadas que puedan generar errores**.

----------

### **ğŸ”¥ Â¿CÃ³mo usar esta validaciÃ³n en Kotlin?**

Si quieres validar el query antes de ejecutarlo en **SQLite**, puedes hacer esto:

```kotlin
val regex = Regex(
    "^(?<StartQuery>SELECT)\\s+(?<Columns>.+?)\\s*\\n(?<QueryFrom>FROM)\\s+(?<TableName>[A-Za-z_][A-Za-z0-9_]*)\\s*(?<Joins>(?:\\s+JOIN\\s+[A-Za-z_][A-Za-z0-9_]*\\s+ON\\s+.+?)*)?\\s*(?<WhereClause>(?:\\s+WHERE\\s+.+?)?)\\s*(?<GroupByClause>(?:\\s+GROUP\\s+BY\\s+.+?)?)\\s*(?<OrderByClause>(?:\\s+ORDER\\s+BY\\s+.+?)?)\\s*(?<LimitClause>(?:\\s+LIMIT\\s+\\d+)?)\\s*(?<EndOfQuery>;)$"
)

fun validateSelectQuery(query: String): Boolean {
    return regex.matches(query)
}

// Ejemplo de uso:
val query = """
    SELECT U.id, U.name, O.order_id, O.amount 
    FROM Users U 
    INNER JOIN Orders O ON U.id = O.user_id;
""".trimIndent()

if (validateSelectQuery(query)) {
    println("âœ… Query vÃ¡lido")
} else {
    println("âŒ Query invÃ¡lido")
}

```

----------

### **ğŸš€ ConclusiÃ³n**

Ahora tienes una **expresiÃ³n regular robusta** para validar `SELECT` en SQLite, asegurando que respete las palabras clave y la sintaxis. Puedes usarla en **Kotlin** antes de ejecutar un query y evitar errores de SQL mal estructurados. ğŸš€ğŸ”¥